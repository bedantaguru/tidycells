% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_utils.R
\name{util_hierarchical_rank}
\alias{util_hierarchical_rank}
\title{Assign Group Ranks After Multi-Column Ordering}
\usage{
util_hierarchical_rank(..., decreasing = FALSE)
}
\arguments{
\item{...}{Vectors (numeric or character), all of the same length, to rank
byâ€”first argument has highest priority, then second, etc.}

\item{decreasing}{Logical; if TRUE, sort in decreasing order. Default is
FALSE.}
}
\value{
An integer vector of dense group ranks, length equal to input
vectors.
}
\description{
Returns an integer vector assigning contiguous group ranks (1, 2, ..., n)
after ordering the inputs by all columns, supporting both numeric and
character sorting. Tied rows are assigned the same rank. Supports a variable
number of arguments; all must be the same length.
}
\details{
The sequence of input vectors determines the sorting hierarchy: the first
argument is the primary sort key, the second breaks ties, and so on.
}
\section{Relation to \code{util_natural_segment_rank}}{
 Both
\code{util_hierarchical_rank()} and \link{util_natural_segment_rank} assign
dense ranks based on multi-level, segment-wise numeric ordering.
\code{util_hierarchical_rank()} uses multiple input vectors (columns),
while \link{util_natural_segment_rank} uses a single character vector split
into numeric segments (e.g., "1_10").

When all segments or vectors are numeric and no input is cleaned to blank,
\code{as.integer(util_natural_segment_rank(paste(x1, x2, sep = "_")))} will
give the same result as \code{util_hierarchical_rank(x1, x2)}. However, the
two functions can differ if:
\itemize{
\item The input to \code{util_natural_segment_rank()} contains non-numeric
or extra characters (these are removed during cleaning).
\item After cleaning, some values become blank (""), which are assigned
rank "" (0-equivalent), and ranking starts from 1 for the rest.
}
}

\section{Benchmark}{
 For 10,000 rows, \code{util_hierarchical_rank()} is about
10x faster (median ~1.8 ms) than \code{util_natural_segment_rank()} (median
~22.8 ms), because the latter incurs additional overhead from string
splitting and conversion.
}

\examples{
\dontrun{
x1 <- c("b", "a", "a", "b", "c", "b")
x2 <- c(2, 3, 2, 2, 1, 2)
util_hierarchical_rank(x1, x2)

n1 <- c(5, 1, 1, 5)
n2 <- c(2, 3, 2, 2)
util_hierarchical_rank(n1, n2, decreasing = TRUE)

# Same result as util_natural_segment_rank() if all segments are numeric and no blanks:
util_hierarchical_rank(x1 = 1:3, x2 = c(2, 10, 2)) # 1 3 2
as.integer(util_natural_segment_rank(paste(1:3, c(2, 10, 2), sep = "_"))) # 1 3 2
}

}
\seealso{
\link{util_natural_segment_rank}
}
\keyword{internal}
